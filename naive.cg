// Naive implementation of Knight's Tour.
//
//  cell.r = is knight present on this cell?
//  cell.g =
//  cell.b = Warnsdorff rank at this cell
//  cell.a = the next move from this cell
//
float4 main(
  uniform samplerRECT aBoard,
  float2 iPos: WPOS
) : COLOR
{
  // binary encoding of moves to neighboring cells
  //
  //  the @ sign denotes the current cell
  //  numbers denote the neighboring cells
  //
  //          tl     tr
  //
  //          [2][ ][0]
  //  lt   [6]   [ ]   [4]   rt
  //       [ ][ ][@][ ][ ]
  //  lb   [7]   [ ]   [5]   rb
  //          [3][ ][1]
  //
  //          bl     br
  //
  static const half // k i j   x   y  designation
    MOVE_TR   = 0,  // 0 0 0   1   2  top right
    MOVE_BR   = 1,  // 0 0 1   1  -2  bottom right
    MOVE_TL   = 2,  // 0 1 0  -1   2  top left
    MOVE_BL   = 3,  // 0 1 1  -1  -2  bottom left
    MOVE_RT   = 4,  // 1 0 0   2   1  right top
    MOVE_RB   = 5,  // 1 0 1   2  -1  right bottom
    MOVE_LT   = 6,  // 1 1 0  -2   1  left top
    MOVE_LB   = 7,  // 1 1 1  -2  -1  left bottom
    MOVE_NONE = 8
  ;

  // rank can only be at most 8 (there are at most 8 neighbors per cell)
  static const half RANK_NONE = 9;

  // width of the chess board
  static const int WIDTH = 8;


  float4 self = texRECT(aBoard, iPos);
  int rank = 0;
  float minRank = RANK_NONE;
  float nextMove = MOVE_NONE;

  // iterate through neighboring cells
    float2 itr = float2(1, 2);

    for (int k = 0; k < 2; k++) {
      for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
          // relative offset of neighboring cell
          float2 offset = itr * float2(pow(-1, fixed(i)), pow(-1, fixed(j)));

          // position of neighboring cell
          float2 pos = iPos + offset;

          // ignore out-of-bounds indices because texRECT() will clamp them to the border of the grid
          if (
            pos.x >= 0 && pos.x < WIDTH &&
            pos.y >= 0 && pos.y < WIDTH
          ){
            float4 cell = texRECT(aBoard, pos);

            // calculate Warnsdorff ranking
              if (cell.r == 0)
                rank++;

            // calculate knight's next move
              if (cell.b < minRank) {
                minRank = cell.b;
                nextMove = (4 * k) + (2 * i) + j; // binary encoding (see MOVE_* constants above)
              }
          }
        }
      }

      itr.xy = itr.yx;
    }

  self.b = rank;
  self.a = nextMove;
  return self;
}
