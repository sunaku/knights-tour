// Naive implementation of Knight's Tour.
//
//  cell.r = is knight present on this cell?
//  cell.g = knight's descision-cycle counter
//  cell.b = Warnsdorff rank at this cell
//  cell.a = the next move from this cell
//
float4 main(
  uniform samplerRECT aBoard,
  float2 iPos: WPOS
) : COLOR
{
  <%
    # binary encoding of moves to neighboring cells
    #
    #  the @ sign denotes the current cell
    #  numbers denote the neighboring cells
    #
    #          tl     tr
    #
    #          [2][ ][0]
    #  lt   [6]   [ ]   [4]   rt
    #       [ ][ ][@][ ][ ]
    #  lb   [7]   [ ]   [5]   rb
    #          [3][ ][1]
    #
    #          bl     br
    #
    MOVE_NONE = 8   # k i j   x   y  designation
    MOVE_TR   = 0   # 0 0 0   1   2  top right
    MOVE_BR   = 1   # 0 0 1   1  -2  bottom right
    MOVE_TL   = 2   # 0 1 0  -1   2  top left
    MOVE_BL   = 3   # 0 1 1  -1  -2  bottom left
    MOVE_RT   = 4   # 1 0 0   2   1  right top
    MOVE_RB   = 5   # 1 0 1   2  -1  right bottom
    MOVE_LT   = 6   # 1 1 0  -2   1  left top
    MOVE_LB   = 7   # 1 1 1  -2  -1  left bottom

    def outward_motion k, i, j
      (k << 2) | (i << 1) | j
    end

    def inward_motion k, i, j
      m = outward_motion(k, i, j)
      (m & 0b100) | (~m & 0b011)
    end

    # rank can only be at most 8 (there are at most 8 neighbors per cell)
    RANK_NONE = 8 + 1 # +1 because we calculate MIN rank

    # number of cycles necessary before making a move:
    # cycle 1: rank computed
    # cycle 2: minRank & nextMove computed
    # cycle 3: move is made
    EXPORT_DELAY = 3
    IMPORT_DELAY = EXPORT_DELAY - 1
  %>

  // width of the chess board
  static const int WIDTH = 8;

  // marker which denotes the knight
  static const int CELL_KNIGHT = WIDTH * WIDTH;
  static const int CELL_EMPTY = 0;


  float4 self = texRECT(aBoard, iPos);

  int rank = 0;
  int nextMove = <%= MOVE_NONE %>;
  float minRank = <%= RANK_NONE %>;

  // iterate through neighboring cells
    float2 pos;
    float4 cell;
    <%
      itr = [1, 2]

      2.times do |k|
        2.times do |i|
          2.times do |j|
            dx = itr[0] * ((-1) ** i)
            dy = itr[1] * ((-1) ** j)

            # going from myself to neighbor
            motionToNeighbor    = (k << 2) | (i << 1)   | j

            # coming to myself from neighbor
            motionFromNeighbor  = (k << 2) | (1-i << 1) | (1-j)
          %>
            // position of neighboring cell
            pos = iPos + float2(<%= dx %>, <%= dy %>);

            // ignore out-of-bounds indices because texRECT() will clamp them to the border of the grid
            if (
              pos.x >= 0 && pos.x < WIDTH &&
              pos.y >= 0 && pos.y < WIDTH
            ){
              cell = texRECT(aBoard, pos);

              if (cell.r == CELL_EMPTY) {
                // calculate Warnsdorff ranking
                  rank++;

                // calculate knight's next move
                  if (cell.b < minRank) {
                    minRank = cell.b;
                    nextMove = <%= outward_motion(k, i, j) %>;
                  }
              }

              // move neighboring knight onto myself
                if (
                  self.r == CELL_EMPTY &&

                  // neighbor is a knight
                  cell.r == CELL_KNIGHT &&

                  // knight wants to move onto me
                  cell.a == <%= inward_motion(k, i, j) %> &&

                  // knight is ready to move
                  cell.g == <%= IMPORT_DELAY %>
                ){
                  self.r = CELL_KNIGHT;
                }
            }
          <%
          end
        end

        # handle the other hemisphere (top vs. bottom)
        itr.reverse!
      end
    %>

  // move the knight
    if (self.r == CELL_KNIGHT) {
      self.g++;

      // wait for nextMove to converge (since it depends on the rank calculated in previous cycle) before moving onwards to the next cell
      if (self.g == <%= EXPORT_DELAY %>) {
        self.r = 1;
      }
    }

  self.b = rank;
  self.a = nextMove;
  return self;
}
